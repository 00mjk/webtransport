<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <link href="include/style.css" rel="stylesheet">
  <title>WebTransport</title>
  <script src="include/respec-w3c-common.js" class="remove" type="text/javascript"></script>
  <script src="include/respec-config.js" class="remove" type="text/javascript"></script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a set of ECMAScript APIs in WebIDL to allow data to be sent
    and received between a browser and server, implementing pluggable
    protocols underneath with common APIs on top.  APIs specific to QUIC are also provided.
    This specification is being developed in conjunction with a protocol
    specification developed by the IETF QUIC Working Group.</p>
  </section>

  <section id="sotd">
  </section>

  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>This specification uses pluggable protocols, with
    QUIC [[!QUIC-TRANSPORT]] as one such protocol, to send data
    to and receive data from servers.  It can be used like WebSockets
    but with support for multiple streams, unidirectional streams,
    out-of-order delivery, and reliable as well as unreliable transport.</p>
    <p class="note">The API presented in this specification
    represents a preliminary proposal based on work-in-progress
    within the IETF QUIC WG. Since the QUIC transport specification is
    a work-in-progress, both the protocol and API are likely to
    change significantly going forward.</p>
  </section>

  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification <em class="rfc2119" title="MUST">MUST</em> implement them
    in a manner consistent with the ECMAScript Bindings defined in the Web IDL
    specification [[!WEBIDL-1]], as this specification uses that specification
    and terminology.</p>
  </section>

  <section>
    <h2>Terminology</h2>
     <p>The <code><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
      interface, representing a callback used for event handlers, and the <a href=
      "http://dev.w3.org/html5/spec/webappapis.html#errorevent"><code><dfn>ErrorEvent</dfn></code></a>
      interface are defined in [[!HTML51]].</p>
      <p>The concepts <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a></dfn>,
      <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a simple
      event</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#networking-task-source">networking
      task source</a></dfn> are defined in [[!HTML51]].</p>
      <p>The terms <dfn>event</dfn>, <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
      handlers</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
      handler event types</a></dfn> are defined in [[!HTML51]].</p>
     <p>When referring to exceptions, the terms <dfn><a
      href="https://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a></dfn> and
      <dfn data-dfn-for="exception"><a href=
      "https://www.w3.org/TR/WebIDL-1/#dfn-create-exception">create</a></dfn> are
      defined in [[!WEBIDL-1]].</p>
      <p>The terms <dfn data-lt="fulfill|fulfillment">fulfilled</dfn>, <dfn
      data-lt="reject|rejection|rejecting|rejected">rejected</dfn>,
      <dfn data-lt="resolve|resolves">resolved</dfn>, <dfn>pending</dfn> and
      <dfn data-lt="settled">settled</dfn> used in the context of Promises are defined in
      [[!ECMASCRIPT-6.0]].</p>
      <p>The terms <dfn>ReadableStream</dfn> and <dfn>WritableStream</dfn> are defined in
        [[!WHATWG-STREAMS]].</p>
  </section>

  <section id="unidirectional-streams-transport*">
    <h2><dfn>UnidirectionalStreamsTransport</dfn> Mixin</h2>
    <p>
      A <code>UnidirectionalStreamsTransport</code> can send and receive unidirectional streams.
      Data within a stream is delivered in order, but data between streams may be delivered out of order.
      Data is generally sent reliably, but retransmissions may be disabled
      or the stream may aborted to produce a form of unreliability.
      All stream data is encrypted and congestion-controlled.
    </p>
    <pre class="idl">
interface mixin UnidirectionalStreamsTransport {
  Promise&lt;SendStream&gt; createSendStream (optional SendStreamParameters parameters);
  ReadableStream            receiveStreams ();
};</pre>
    <section>
      <h2>Methods</h2>
      <dl data-link-for="UnidirectionalStreamsTransport" data-dfn-for="UnidirectionalStreamsTransport" class=
      "methods">
        <dt><dfn><code>createSendStream</code></dfn></dt>
        <dd>
          <p>Creates an <code><a>SendStream</a></code> object.</p>
          <p>When <code>createSendStream</code> is called, the user agent
          <em class="rfc2119" title="MUST">MUST</em> run the following
          steps:</p>
          <ol>
            <li>
              <p>Let <var>transport</var> be the <code><a>UnidirectionalStreamsTransport</a></code>
              on which <code>createSendStream</code> is invoked.</p>
            </li>
            <li>
              <p>If <code><var>transport</var>'s state</code> is <code>"closed"</code> or
              <code>"failed"</code>, immediately return a new <a>rejected</a> promise with a
              newly created <code>InvalidStateError</code> and abort these steps.</p>
            </li>
            <li>
	      <!-- TODO If/when we support 0-RTT, allow resoling the
	      stream before we are connected. -->
              <p>If <code><var>transport</var>'s state</code> is <code>"connected"</code>,
              immediately return a new <a>resolved</a> promise with a newly created
              <code><a>SendStream</a></code> object,
              <a>add the SendStream</a> to the <var>transport</var>
              and abort these steps.</p>
            </li>
            <li>
              <p>Let <var>p</var> be a new promise.</p>
            </li>
            <li>
              <p>Return <var>p</var> and continue the following steps in
              the background.</p>
            </li>
            <li>
              <p>
                <a>Resolve</a> <var>p</var> with a newly created
                <code><a>SendStream</a></code> object and
                <a>add the SendStream</a> to the <var>transport</var>
                when all of the following conditions are met:</p>
                <ol>
                  <li>
                    <p>The <code><var>transport</var>'s state</code> has transitioned to
                    <code>"connected"</code></p>
                  </li>
                  <li> 
                    <p>Stream creation flow control is not being violated by exceeding
                    the max stream limit set by the remote endpoint, as specified in
                    [[QUIC-TRANSPORT]].</p>
                  </li>
                  <li>
                    <p><var>p</var> has not been <a>settled</a></p>
                  </li>
                </ol>
              </p>
            </li>
            <li>
              <p>
                <a>Reject</a> <var>p</var> with a newly created
                <code>InvalidStateError</code> when all of the following conditions are met:
                <ol>
                  <li>
                    <p>The <code><var>transport</var>'s state</code> transitions to
                      <code>"closed"</code> or <code>"failed"</code></p>
                  </li>
                  <li>
                    <p><var>p</var> has not been <a>settled</a></p>
                  </li>
                </ol>
              </p>
            </li>
          </ol>
          <div>
            <em>No parameters.</em>
          </div>
          <div>
            <em>Return type:</em> <code><a>Promise&lt;SendStream&gt;</a></code>
          </div>
        </dd>
        <dt><dfn><code>receiveStreams</code></dfn></dt>
        <dd>
          <p>Returns a <code><a>ReadableStream</a></code> of <code><a>ReceiveStream</a></code>s
          that have been received from the remote host.</p>
          <p>When <code>receiveStreams</code> is called, the user agent
          <em class="rfc2119" title="MUST">MUST</em> run the following
          steps:</p>
          <ol>
            <li>
              <p>Let <var>transport</var> be the <code><a>UnidirectionalStreamsTransport</a></code>
              on which <code>receiveStreams</code> is invoked.</p>
            </li>
            <li>
              <p>Return the value of the <dfn>[[\ReceivedStreams]]</dfn> internal slot.</p>
            </li>
            <li>
              <p>For each unidirectional stream received, create a
                corresponding <code><a>IncomingStream</a></code> and
                insert it into <dfn>[[\ReceivedStreams]]</dfn>.  As
                data is received over the unidirectional stream, insert
                that data into the corresponding <code><a>IncomingStream</a></code>
                When the remote side closes or aborts the stream,
                close or abort the corresponding <code><a>IncomingStream</a></code>.
              <p>
              <p>
            </li>
          </ol>
          <div>
            <em>No parameters.</em>
          </div>
          <div>
            <em>Return type:</em> <code><a>ReadableStream</a></code>
          </div>
        </dd>
      </dl>
    </section>
    <section id="UnidirectionalStreamsTransport-procedures*">
      <h3>Procedures</h3>
      <section>
        <h4 id="add-send-stream-to-transport">Add SendStream to the UnidirectionalStreamsTransport</h4>
        <p>To <dfn>add the SendStream</dfn> to the <code><a>UnidirectionalStreamsTransport</a></code>
        run the following steps:</p>
        <ol>
          <li>
            <p>Let <var>stream</var> be the newly created
            <code><a>SendStream</a></code> object.</p>
          </li>
          <li>
            <p>Add <var>stream</var> to <var>transport</var>'s <a>[[\OutgoingStreams]]</a>
            internal slot. </p>
          </li>
          <li>
            <p>Continue the following steps in the background.</p>
          </li>
          <li>
            <p>Create <var>stream</var>'s associated underlying
            transport.</p>
          </li>
        </ol>
      </section>
    </section>
    <section id="streamparameters*">
      <h3><dfn>SendStreamParameters</dfn> Dictionary</h3>
      <p>The <code>QuicStreamParameters</code> dictionary includes information
      relating to stream configuration.</p>
      <div>
        <pre class="idl">dictionary SendStreamParameters {
              bool disableRetransmissions = false;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">SendStreamParameters</a> Members</h2>
          <dl data-link-for="SendStreamParameters" data-dfn-for="SendStreamParameters" class=
          "dictionary-members">
            <dt><dfn><code>disableRetransmissions</code></dfn> of type <span class=
            "idlMemberType"><a>bool</a></span>, defaulting to
            <code>false</code></dt>
            <dd>
              <p>disableRetransmissions, with a default of <code>false</code>.  If
              true, the stream will be sent without retransmissions.  If false, the
              stream will be sent with retransmissions.
              If the WebTransport is unable to send without retransmissions, it may ignore this value.
              <!-- TODO: Provide some API surface to indidcate
                   that the transport doesn't support disabling retransmissions -->
	      </p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>

  <section id="bidirectional-streams-transport*">
    <h2><dfn>BidirectionalStreamsTransport</dfn> Mixin</h2>
    <p>
      A <code>BidirectionalStreamsTransport</code> can send and receive bidirectional streams.
      Data within a stream is delivered in order, but data between streams may be delivered out of order.
      Data is generally sent reliably, but retransmissions may be disabled
      or the stream may aborted to produce a form of unreliability.
      All stream data is encrypted and congestion-controlled.
    </p>
    <pre class="idl">
interface BidirectionalStreamsTransport {
    Promise&lt;BidirectionalStream&gt; createBidirectionalStream ();
    ReadableStream                     receiveBidirectionalStreams ();
};</pre>
    <section>
      <h2>Methods</h2>
      <dl data-link-for="BidirectionalStreamsTransport" data-dfn-for="BidirectionalStreamsTransport" class=
      "methods">
        <dt><dfn><code>createBidirectionalStream</code></dfn></dt>
        <dd>
          <p>Creates an <code><a>BidirectionalStream</a></code> object.</p>
          <p>When <code>createBidectionalStream</code> is called, the user agent
          <em class="rfc2119" title="MUST">MUST</em> run the following
          steps:</p>
          <ol>
            <li>
              <p>Let <var>transport</var> be the <code><a>BidirectionalStreamsTransport</a></code>
              on which <code>createBidectionalStream</code> is invoked.</p>
            </li>
            <li>
              <p>If <code><var>transport</var>'s state</code> is <code>"closed"</code> or
              <code>"failed"</code>, immediately return a new <a>rejected</a> promise with a
              newly created <code>InvalidStateError</code> and abort these steps.</p>
            </li>
            <li>
              <p>If <code><var>transport</var>'s state</code> is <code>"connected"</code>,
              immediately return a new <a>resolved</a> promise with a newly created
              <code><a>BidirectionalStream</a></code> object,
              <a>add the BidirectionalStream</a> to the <var>transport</var>
              and abort these steps.</p>
            </li>
            <li>
              <p>Let <var>p</var> be a new promise.</p>
            </li>
            <li>
              <p>Return <var>p</var> and continue the following steps in
              the background.</p>
            </li>
            <li>
                <p>
                  <a>Resolve</a> <var>p</var> with a newly created
                  <code><a>BidirectionalStream</a></code> object and
                  <a>add the BidirectionalStream</a> to the <var>transport</var>
                  when all of the following conditions are met:</p>
                  <ol>
                    <li>
                      <p>The <code><var>transport</var>'s state</code> has transitioned to
                      <code>"connected"</code></p>
                    </li>
                    <li> 
                      <p>Stream creation flow control is not being violated by exceeding
                      the max stream limit set by the remote endpoint, as specified in
                      [[QUIC-TRANSPORT]].</p>
                    </li>
                    <li>
                      <p><var>p</var> has not been <a>settled</a></p>
                    </li>
                  </ol>
                </p>
              </li>
              <li>
                <p>
                  <a>Reject</a> <var>p</var> with a newly created
                  <code>InvalidStateError</code> when all of the following conditions are met:
                  <ol>
                    <li>
                      <p>The <code><var>transport</var>'s state</code> transitions to
                        <code>"closed"</code> or <code>"failed"</code></p>
                    </li>
                    <li>
                      <p><var>p</var> has not been <a>settled</a></p>
                    </li>
                  </ol>
                </p>
              </li>
          </ol>
          <div>
            <em>No parameters.</em>
          </div>
          <div>
            <em>Return type:</em> <code><a>Promise&lt;BidirectionalStream&gt;</a></code>
          </div>
        </dd>
        <dt><dfn><code>receiveBidirectionalStreams</code></dfn></dt>
        <dd>
          <p>Returns a <code><a>ReadableStream</a></code> of <code><a>BidirectionalStream</a></code>s
          that have been received from the remote host.</p>
          <p>When <code>receiveBidirectionalStreams</code> is called, the user agent
          <em class="rfc2119" title="MUST">MUST</em> run the following
          steps:</p>
          <ol>
            <li>
              <p>Let <var>transport</var> be the <code><a>UnidirectionalStreamsTransport</a></code>
              on which <code>receiveStreams</code> is invoked.</p>
            </li>
            <li>
              <p>Return the value of the <dfn>[[\ReceivedBidirectionalStreams]]</dfn> internal slot.</p>
            </li>
            <li>
              <p>For each bidirectional stream received, create a
                corresponding <code><a>IncomingStream</a></code> and
                insert it into <dfn>[[\ReceivedBidirectionalStreams]]</dfn>.  As
                data is received over the bidirectional stream, insert
                that data into the corresponding <code><a>IncomingStream</a></code>.
                When the remote side closes or aborts the stream,
                close or abort the corresponding <code><a>IncomingStream</a></code>.
              <p>
            </li>
          </ol>
          <div>
            <em>No parameters.</em>
          </div>
          <div>
            <em>Return type:</em> <code><a>ReadableStream</a></code>
          </div>
        </dd>
      </dl>
    </section>
    <section id="BidirectionalStreamsTransport-procedures*">
      <h3>Procedures</h3>
      <section>
        <h4 id="add-bidirectional-stream-to-transport">Add BidirectionalStream
        to the BidirectionalStreamsTransport</h4>
        <p>To <dfn>add the BidirectionalStream</dfn> to the <code><a>BidirectionalStreamsTransport</a></code>
        run the following steps:</p>
        <ol>
          <li>
            <p>Let <var>stream</var> be the newly created
            <code><a>BidirectionalStream</a></code> object.</p>
          </li>
          <li>
            <p>Add <var>stream</var> to <var>transport</var>'s <a>[[\ReceivedBidirectionalStreams]]</a>
            internal slot. </p>
          </li>
          <li>
            <p>Add <var>stream</var> to <var>transport</var>'s <a>[[\OutgoingStreams]]</a>
            internal slot. </p>
          </li>
          <li>
            <p>Continue the following steps in the background.</p>
          </li>
          <li>
            <p>Create <var>stream</var>'s associated underlying
            transport.</p>
          </li>
        </ol>
      </section>
    </section>
  </section>

  <section id="datagram-transport*">
    <h2><dfn>DatagramTransport</dfn> Mixin</h2>
    <p>
      A <code>DatagramTransport</code> can send and receive datagrams.
      Datagrams are sent out of order, unreliably, and have a limited maximum size.
      Datagrams are encrypted and congestion controlled.
      </p>
      <pre class="idl">
interface mixin DatagramTransport {
    readonly attribute unsigned short maxDatagramSize;
    WritableStream                    sendDatagrams ();
    ReadableStream                    receiveDatagrams ();
};</pre>
    <section>
      <h2>Attributes</h2>
      <dl data-link-for="DatagramTransport" data-dfn-for="DatagramTransport" class=
        "attributes">

        <dt><dfn><code>maxDatagramSize</code></dfn> of type <span class=
        "idlAttrType"><a>unsigned short</a></span>, readonly</dt>
        <dd>
          <p>The maximum size data that may be passed to sendDatagram.</p>
        </dd>
      </dl>
    </section>
    <section>
      <h2>Methods</h2>
      <dl data-link-for="DatagramTransport" data-dfn-for="DatagramTransport" class=
      "methods">
        <dt><dfn><code>sendDatagrams</code></dfn></dt>
        <dd>
          <p>Sends datagrams that are written to the returned WritableStream.</p>
          <p>When <code>sendDatagram</code> is called, the user agent
          <em class="rfc2119" title="MUST">MUST</em> run the following
          steps:</p>
          <ol>
            <li>
              <p>Let <var>transport</var> be
              the <code><a>DatagramTransport</a></code> on
              which <code>sendDatagram</code> is invoked.</p>
            </li>
            <li>
              <p>Return the value of the <dfn>[[\SentDatagrams]]]</dfn> internal slot.</p>
            </li>
            <!-- TODO: Figure out how to indicate to JS that a datagram has been acked  
                       or dropped. -->
          </ol>
          <div>
            <em>Return type:</em> <code>WritableStream</code>
          </div>
        </dd>
        <dt><dfn><code>receiveDatagrams</code></dfn></dt>
        <dd>
          <p>Return the value of the <dfn>[[\ReceivedDatagrams]]</dfn> internal slot.</p>
          <p>For each datagram received, insert it into <dfn>[[\ReceivedDatagrams]]</dfn>.  
             If too many datagrams are queued because the stream
             is not being read quickly enough, drop datagrams to avoid queueing.<p>
          <div>
            <em>Return type:</em> <code>ReadableStream</code>
          </div>
        </dd>
      </dl>
    </section>
  </section>

  <section id="web-transport*">
    <h2><dfn>WebTransport</dfn> Mixin</h2>
    <p>
      The <code>WebTransport</code> includes the methods common to all transports,
      such as state, state changes, and the ability to close the transport.
    </p>
    <pre class="idl">
interface mixin WebTransport {
  readonly attribute WebTransportState state;
  void                                  close (WebTransportCloseInfo closeInfo);
           attribute EventHandler       onstatechange;
           attribute EventHandler       onerror;
};</pre>
    <section>
      <h2>Attributes</h2>
      <dl data-link-for="WebTransport" data-dfn-for="WebTransport" class=
      "attributes">
        <dt><dfn><code>state</code></dfn> of type <span class=
        "idlAttrType"><a>WebTransportState</a></span>, readonly</dt>
        <dd>
          <p>The current state of the transport. On getting, it
          <em class="rfc2119" title="MUST">MUST</em> return the value
          of the <a>[[\WebTransportState]]</a> internal slot.</p>
        </dd>

        <dt><dfn><code>onstatechange</code></dfn> of type <span class=
        "idlAttrType"><a>EventHandler</a></span></dt>
        <dd>
          <p>This event handler, of event handler event type
          <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
          be fired any time the <a>[[\WebTransportState]]</a> slot changes, unless
          the state changes due to calling <a><code>close</code></a>.</p>
        </dd>

        <dt><dfn><code>onerror</code></dfn> of type <span class=
        "idlAttrType"><a>EventHandler</a></span></dt>
        <dd>
          <p>This event handler, of event handler event type <code>error</code>,
          <em class="rfc2119" title="MUST">MUST</em> be fired on reception of an
          error; an implementation <em class="rfc2119" title=
          "SHOULD">SHOULD</em> include error information in
          <var>error.message</var> (defined in [[!HTML51]] Section 7.1.3.8.2). This
          event <em class="rfc2119" title="MUST">MUST</em> be fired before the
          <a><code>onstatechange</code></a> event.</p>
        </dd>
      </dl>
    </section>
    <section>
      <h2>Methods</h2>
      <dl data-link-for="WebTransport" data-dfn-for="WebTransport" class=
      "methods">
        <!-- TODO: Should this be moved out of WebTransport?
             It might different for each type of transport. -->
        <dt><dfn><code>close</code></dfn></dt>
        <dd>
          <p>Closes the <code><a>WebTransport</a></code> object.
          <!-- TODO: move reference to QUIC under QuicTransportBase. -->
          For QUIC, this triggers an <dfn>Immediate Close</dfn> as described in [[QUIC-TRANSPORT]] section 10.3.
          <p>When <code>close</code> is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
          run the following steps:</p>
          <ol>
            <li>Let <var>transport</var> be the <code><a>WebTransport</a></code>
            on which <code>close</code> is invoked.</li>
            <li>If <var>transport</var>'s <a>[[\WebTransportState]]</a> is <code>"closed"</code>
            then abort these steps.</li>
            <li>Set <var>transport</var>'s <a>[[\WebTransportState]]</a> to
            <code>"closed"</code>.</li>
            <li>Let <code>closeInfo</code> be the first argument.</li>
            <!-- TODO: move reference to QUIC under QuicTransportBase. -->
            <li>For QUIC, start the <a>Immediate Close</a> procedure by sending an CONNECTION_CLOSE frame
            with its error code value set to the value of <var>closeInfo</var>.errorCode
            and its reason value set to the value of <var>closeInfo</var>.reason.</li>
          </ol>
          <div>
            <em>No parameters.</em>
          </div>
          <div>
            <em>Return type:</em> <code>void</code>
          </div>
          <table class="parameters">
            <tbody>
              <tr>
                <th>Parameter</th>
                <th>Type</th>
                <th>Nullable</th>
                <th>Optional</th>
                <th>Description</th>
              </tr>
              <tr>
                <td class="prmName">closeInfo</td>
                <td class="prmType"><code>WebTransportCloseInfo</code></td>
                <td class="prmNullFalse"><span role="img" aria-label=
                "False">&#10008;</span></td>
                <td class="prmOptFalse"><span role="img" aria-label=
                "False">&#10008;</span></td>
                <td class="prmDesc"></td>
              </tr>
            </tbody>
          </table>
        </dd>
      </dl>
    </section>
    <section id="WebTransportState*">
      <h3><dfn>WebTransportState</dfn> Enum</h3>
      <p><code>WebTransportState</code> indicates the state of the
      transport.</p>
      <div>
        <pre class="idl">
enum WebTransportState {
    "new",
    "connecting",
    "connected",
    "closed",
    "failed"
};</pre>
        <table data-link-for="WebTransportState" data-dfn-for="WebTransportState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-WebTransportState.new">new</code></dfn></td>
              <td>
                <p>The <code><a>WebTransport</a></code> object has been created and
                has not started negotiating yet.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-WebTransportState.connecting">connecting</code></dfn></td>
              <td>
                <p>The transport is in the process of negotiating a secure connection.
                Once a secure connection is negotiated, incoming data can flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-WebTransportState.connected">connected</code></dfn></td>
              <td>
                <p>The transport has completed negotiation of a secure connection.
                Outgoing data and media can now flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-WebTransportState.closed">closed</code></dfn></td>
              <td>
                <p>The transport has been closed intentionally via a call to
                <code>close()</code> or receipt of a closing message from the remote side.
                When the <code><a>WebTransport</a></code>'s
                internal <a>[[\WebTransportState]]</a> slot transitions to
                <code>closed</code> the user agent <em class="rfc2119" title="MUST">MUST</em>
                run the following steps:</p>
                <ol>
                  <li>Let <var>transport</var> be the <code><a>WebTransport</a></code>.
                  <li>Close the <code><a>ReadableStream</a></code> in <var>transport</var>'s
                  <a>[[\ReceivedStreams]]</a> internal slot.</li>
                  <li>Close the <code><a>ReadableStream</a></code> in <var>transport</var>'s
                  <a>[[\ReceivedBidirectionalStreams]]</a> internal slot.</li>
                  <li>For each <code><a>OutgoingStream</a></code> in <var>transport</var>'s
                  <a>[[\OutgoingStreams]]</a> internal slot run the
                  following:</li>
                  <ol>
                    <li>Let <var>stream</var> be the <code><a>OutgoingStream</a></code>.</li>
                    <li>Remove the <var>stream</var> from the <var>transport</var>'s
                    <a>[[\OutgoingStreams]]</a> internal slot.
                  </ol>
                </ol>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-WebTransportState.failed">failed</code></dfn></td>
              <td>
                <p>The transport has been closed as the result of an error (such as
                receipt of an error alert). When the <code><a>WebTransport</a></code>'s
                internal <a>[[\WebTransportState]]</a> slot transitions to
                <code>failed</code> the user agent <em class="rfc2119" title="MUST">MUST</em>
                run the following steps:</p>
                <ol>
                  <li>Close the <code><a>ReadableStream</a></code> in <var>transport</var>'s
                  <a>[[\ReceivedStreams]]</a> internal slot.</li>
                  <li>Close the <code><a>ReadableStream</a></code> in <var>transport</var>'s
                  <a>[[\ReceivedBidirectionalStreams]]</a> internal slot.</li>
                  <li>For each <code><a>OutgoingStream</a></code> in <var>transport</var>'s
                  <a>[[\OutgoingStreams]]</a> internal slot run the
                  following:</li>
                  <ol>
                    <li>Remove the <var>stream</var> from the <var>transport</var>'s
                    <a>[[\OutgoingStreams]]</a> internal slot.
                  </ol>
                </ol>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="webtransportcloseinfo*">
      <h3><dfn>WebTransportCloseInfo</dfn> Dictionary</h3>
      <p>The <code>WebTransportCloseInfo</code> dictionary includes information
      relating to the error code for closing a <code><a>WebTransport</a></code>.
      For QUIC, this information is used to set the error code and reason for an CONNECTION_CLOSE
      frame.</p>
      <div>
        <pre class="idl">
dictionary WebTransportCloseInfo {
    unsigned short errorCode = 0;
    DOMString reason = "";
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">WebTransportCloseInfo</a> Members</h2>
          <dl data-link-for="WebTransportCloseInfo" data-dfn-for="WebTransportCloseInfo" class=
          "dictionary-members">
            <dt><dfn><code>errorCode</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>, defaulting to
            <code>0</code>.</dt>
            <dd>
              <p>The error code.</p>
            </dd>
            <dt><dfn><code>reason</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, defaulting to <code>""</code></dt>
            <dd>
              <p>The reason for closing the <code><a>WebTransport</a></code></p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>

  <section id="quic-transport-base*">
    <h2><dfn>QuicTransportBase</dfn> Interface</h2>
    <p>The <code>QuicTransportBase</code> is the base interface
      for <code>QuicTransport</code>.  Most of the functionality of a
      QuicTransport is in the base class to allow for other
      subclasses (such as a p2p variant) to share the same interface.
    </p>
    <section id="quictransportbase-overview*">
      <h3>Overview</h3>
      <p>A <code><a>QuicTransportBase</a></code> is a
      <code>UnidirectionalStreamsTransport</code>, a
      <code>BidirectionalStreamsTransport</code>, and a
      <code>DatagramTransport</code>.
      SendStreams and ReceiveStreams are implemented with unidirectional QUIC streams as defined in [[!QUIC-TRANSPORT]].
      BidirectionalStreams are implemented with bidirectional QUIC streams as defined in [[!QUIC-TRANSPORT]].
      Datagrams are implemented with QUIC datagrams as defined in [[QUIC-DATAGRAM]].
      </p>
    </section>
    <section id="quictransportbase-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
interface QuicTransportBase {
};

QuicTransportBase includes UnidirectionalStreamsTransport;
QuicTransportBase includes BidirectionalStreamsTransport;
QuicTransportBase includes DatagramTransport;
QuicTransportBase includes WebTransport;</pre>
      </div>
    </section>
  </section>

  <section id="quic-transport*">
    <h2><dfn>QuicTransport</dfn> Interface</h2>
    <p>The <code>QuicTransport</code> is a subclass of
    <code>QuicTransportBase</code> focused on client/server use cases.</p>
    <section id="quictransport-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
[ Constructor (DOMString host, unsigned short port), Exposed=Window]
interface QuicTransport : QuicTransportBase {
};</pre>
        <section>
          <h2>Constructors</h2>
          When the <code><a>QuicTransport</a></code> constructor is invoked,
          the user agent <em class="rfc2119" title="MUST">MUST</em> run the
          following steps:
          <ol>
            <li>
                If <var>port</var> is 0,
                <a>throw</a> an <code>NotSupportedError</code> and abort these steps.
            </li>
            <li>
              Let <var>transport</var> be a newly constructed
              <code><a>QuicTransport</a></code> object.
            </li>
            <li>Let <var>transport</var> have a <dfn>[[\OutgoingStreams]]</dfn>
            internal slot representing a sequence of <code><a>OutgoingStream</a></code>
            objects, initialized to empty.
            </li>
            <li>Let <var>transport</var> have a <dfn>[[\ReceivedStreams]]</dfn>
            internal slot representing a <code><a>ReadableStream</a></code>
            of <code><a>IncomingStream</a></code> objects, initialized to empty.
            </li>
            <li>Let <var>transport</var> have a <dfn>[[\ReceivedBidirectionalStreams]]</dfn>
            internal slot representing a <code><a>ReadableStream</a></code>
            of <code><a>IncomingStream</a></code> objects, initialized to empty.
            </li>
            <li>
              Let <var>transport</var> have a <dfn>[[\WebTransportState]]</dfn>
              internal slot, initialized to <code>"connecting"</code>.
            </li>
            <li>Let <var>transport</var> have a <dfn>[[\SentDatagrams]]</dfn>
              internal slot representing a <code>WritableStream</code> of <code>Uint8Array</code>s,
              initialized to empty.
            </li>
            <li>Let <var>transport</var> have a <dfn>[[\ReceivedDatagrams]]</dfn>
              internal slot representing a <code>ReadableStream</code> of <code>Uint8Array</code>s,
              initialized to empty.
            </li>
            <li>Run these steps in parallel:
              <ol>
                <li>
                    Let <var>clientOrigin</var> be <var>transport</var>'s 
                    <a href="https://html.spec.whatwg.org/multipage/webappapis.html#relevant-settings-object">relevant settings object</a>'s
                    <a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-settings-object-origin">origin</a>,
                    <a href="https://html.spec.whatwg.org/multipage/origin.html#ascii-serialisation-of-an-origin">serialized</a>.
                </li>
                <li>
                  Establish a QUIC connection to the address identified by the
                  given host and port following the procedures in
                  [[WEB-TRANSPORT-QUIC]] section 3 and using <var>clientOrigin</var>
                  as the "origin of the client" referenced in section 3.2. 
                </li>
                <li>
                    If the connection fails, set <var>transport</var>'s <a>[[\WebTransportState]]</a>
                    internal slot to <code>"failed"</code> and abort these steps.
                </li>
                <li>
                    Set <var>transport</var>'s <a>[[\WebTransportState]]</a>
                    internal slot to <code>"connected"</code>.
                </li>
              </ol>
            </li>
            <li>
              Return <var>transport</var>.
            </li>
          </ol>          
          <dl data-link-for="QuicTransport" data-dfn-for="QuicTransport" class=
          "constructors">
            <dt><code><a>QuicTransport</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">host</td>
                    <td class="prmType"><code><a>DOMString</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc">The host to connect to.</td>
                  </tr>
                  <tr>
                    <td class="prmName">port</td>
                    <td class="prmType"><code><a>unsigned short</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc">The port to connect to.</td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>

  <section id="outgoing-stream*">
    <h2>Interface Mixin <dfn>OutgoingStream</dfn></h2>
    <p>
      An OutgoingStream is a stream that can be written to,
      as either a <code>SendStream </code>or a <code>BidirectionalStream</code>
    </p>
    <div>
      <pre class="idl">
      [ Exposed=Window ]
interface mixin OutgoingStream {
    readonly attribute WritableStream writable;
    readonly attribute Promise&lt;StreamAbortInfo&gt; writingAborted;
    void abortWriting (StreamAbortInfo abortInfo);
};</pre>
      <section>
        <h3>Overview</h3>
        <p>The <code><a>OutgoingStream</a></code> will initialize with
        the following:</p>
        <ol>
          <li>Let <var>stream</var> be the <code><a>OutgoingStream</a></code>.</li>
          <li>Let <var>stream</var> have a <dfn>[[\Writable]]</dfn> internal
           slot initialized to a new <code>WritableStream</code>.</li>
        </ol>
      </section>
      <section>
        <h3>Attributes</h3>
        <dl data-link-for="OutgoingStream" data-dfn-for="OutgoingStream" class=
        "attributes">
          <dt><code>writable</code> of type <span class="idlAttrType"><a>WritableStream</a></span>
          readonly</dt>
          <dd>
            <p>The <dfn id="dom-outgoingstream-writable"><code>writable</code></dfn>
            attribute represents a WritableStream that can be used to write to the
            <code><a>OutgoingStream</a></code>. On getting it
            <em class="rfc2119" title="MUST">MUST</em> return the value of the
            <a>[[\Writable]]</a> slot.</p>
          </dd>
          <dd>
            <p>The <dfn id="dom-outgoingstream-writingAborted"><code>writingAborted</code></dfn>
            attribute represents a promise that <a>resolves</a> when the
            a message from the remote side aborting the stream is received.
            For QUIC, that message is a STOP_SENDING frame.
            When the <var>stream</var> receives this mesage, the <a>user agent</a>
            <em class="rfc2119" title="MUST">MUST</em> run the following:
            <ol>
              <li>Let <var>stream</var> be the <code><a>OutgoingStream</a></code> object.
              <li>Let <var>transport</var> be the <code><a>WebTransport</a></code>,
              which the <var>stream</var> was created from.
              <li>Remove the <var>stream</var> from the <var>transport</var>'s
              <a>[[\OutgoingStreams]]</a> internal slot.</li>
              <li><a>resolve</a> the promise with the resulting
              <code><a>StreamAbortInfo</a></code> with the <code>errorCode</code>
              set to the value from the aborting message from the remote side.</li>
            </ol>
          </dd>
        </dl>
      </section>
      <section>
        <h3>Methods</h3>
        <dl data-link-for="OutgoingStream" data-dfn-for="OutgoingStream" class=
        "methods">
          <dt><dfn><code>abortWriting</code></dfn></dt>
          <dd>
            <p>A hard shutdown of the <code><a>OutgoingStream</a></code>. It may be called
            regardless of whether the <code><a>OutgoingStream</a></code>
            was created by the local or remote peer. When the <code>abortWriting()</code>
            method is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
            run the following steps:</p>
            <ol>
              <li>Let <var>stream</var> be the <code><a>OutgoingStream</a></code> object
              which is about to abort writing.</li>
              <li>Let <var>transport</var> be the <code><a>WebTransport</a></code>,
              which the <var>stream</var> was created from.</li>
              <li>Remove the <var>stream</var> from the <var>transport</var>'s
              <a>[[\OutgoingStreams]]</a> internal slot.</li>
              <li>Let <var>abortInfo</var> be the first argument.</li>
              <li>Start the closing procedure by sending a RST_STREAM frame with its error
              code set to the value of <var>abortInfo</var>.errorCode.</li>
            </ol>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">abortInfo</td>
                  <td class="prmType"><code>StreamAbortInfo</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc"></td>
                </tr>
              </tbody>
            </table>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
        </dl>
      </section>
      <section id="StreamAbortInfo*">
        <h3><dfn>StreamAbortInfo</dfn> Dictionary</h3>
        <p>The <code>StreamAbortInfo</code> dictionary includes information
        relating to the error code for aborting an incoming or outgoing stream. 
        (For QUIC, in either a RST_STREAM frame or a STOP_SENDING frame).</p>
        <div>
          <pre class="idl">dictionary StreamAbortInfo {
                unsigned short errorCode = 0;
          };
          </pre>
          <section>
            <h2>Dictionary <a class="idlType">StreamAbortInfo</a> Members</h2>
            <dl data-link-for="StreamAbortInfo" data-dfn-for="StreamAbortInfo" class=
            "dictionary-members">
              <dt><dfn><code>errorCode</code></dfn> of type <span class=
              "idlMemberType"><a>unsigned short</a></span>.</dt>
              <dd>
                <p>The error code.  The default value of 0 means "CLOSING."</p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </div>
  </section>

  <section id="incoming-stream*">
    <h2>Interface Mixin <dfn>IncomingStream</dfn></h2>
    <p>
        An IncomingStream is a stream that can be read from,
        as either a <code>ReceiveStream</code> or a <code>BidirectionalStream</code>
    </p>
    <div>
      <pre class="idl">
[ Exposed=Window ]
interface mixin IncomingStream {
    readonly attribute ReadableStream readable;
    readonly attribute Promise&lt;StreamAbortInfo&gt; readingAborted;
    void abortReading (StreamAbortInfo abortInfo);
};</pre>
      <section>
        <h3>Overview</h3>
        <p>The <code><a>IncomingStream</a></code> will initialize with
        the following:</p>
        <ol>
          <li>Let <var>stream</var> be the <code><a>IncomingStream</a></code>.</li>
          <li>Let <var>stream</var> have a <dfn>[[\Readable]]</dfn> internal
          slot initialized to a new <code>ReadableStream</code>.</li>
        </ol>
      </section>
      <section>
        <h3>Attributes</h3>
        <dl data-link-for="IncomingStream" data-dfn-for="IncomingStream" class=
        "attributes">
          <dt><code>readable</code> of type <span class="idlAttrType"><a>ReadableStream</a></span>,
          readonly</dt>
          <dd>
            <p>The <dfn id="dom-incomingstream-readable"><code>readable</code></dfn>
            attribute gives a <code>ReadableStream</code> which can be used to
            read from the <code><a>IncomingStream</a></code>.
            On getting, it <em class="rfc2119" title="MUST">MUST</em> return the value of the
            <code><a>IncomingStream</a></code>'s <a>[[\Readable]]</a> slot.
          </dd>
          <dt><code>readingAborted</code> of type <span class="idlAttriType"><a>StreamAbortInfo</a>
          readonly</dt>
          <dd>
            <p>The <dfn id="dom-incomingstream-readingAborted"><code>readingAborted</code></dfn>
            attribute represents a promise that <a>resolves</a> when the
            a message is received inidicating the remote side aborted the stream.
            For QUIC, this is a RST_STREAM frame.
            When the <var>stream</var> receives this message, the <a>user agent</a>
            <em class="rfc2119" title="MUST">MUST</em> run the following:
            <ol>
              <li>Let <var>stream</var> be the <code><a>IncomingStream</a></code>
              object for which the abort message was received.</li>
              <li>Let <var>transport</var> be the <code><a>WebTransport</a></code>,
              which the <var>stream</var> was created from.
              <li><a>resolve</a> the promise with the resulting
              <code><a>StreamAbortInfo</a></code> with <code>errorCode</code>
              set to the value of the errror code from the abot message.</li>
            </ol>
          </dd>
        </dl>
      </section>
      <section>
        <h3>Methods</h3>
        <dl data-link-for="IncomingStream" data-dfn-for="IncomingStream" class=
        "methods">
          <dt><dfn><code>abortReading</code></dfn></dt>
          <dd>
            <p>A hard shutdown of the <code><a>IncomingStream</a></code>. It may be called
            regardless of whether the <code><a>IncomingStream</a></code> object
            was created by the local or remote peer. When the <code>abortReading()</code>
            method is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
            run the following steps:</p>
            <ol>
              <li>Let <var>stream</var> be the <code><a>IncomingStream</a></code> object
              which is about to abort reading.</li>
              <li>Let <var>transport</var> be the <code><a>WebTransport</a></code>,
              which the <var>stream</var> was created from.
              <li>Let <var>abortInfo</var> be the first argument.</li>
              <li>Start the closing procedure by sending a message to the remote side indicating
                that the stream has been aborted (for QUIC, this is a STOP_SENDING frame) with its error
                code set to the value of <var>abortInfo</var>.errorCode.</li>
            </ol>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Nullable</th>
                  <th>Optional</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td class="prmName">abortInfo</td>
                  <td class="prmType"><code>StreamAbortInfo</code></td>
                  <td class="prmNullFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmOptFalse"><span role="img" aria-label=
                  "False">&#10008;</span></td>
                  <td class="prmDesc"></td>
                </tr>
              </tbody>
            </table>
            <div>
              <em>Return type:</em> <code>void</code>
            </div>
          </dd>
        </dl>
      </section>
    </div>
  </section>

  <section id="web-transport-stream*">
    <h2>Interface <dfn>WebTransportStream</dfn></h2>
    <p>A collection of common attributes and methods of all streams.</p>
    <div>
      <pre class="idl">
      [ Exposed=Window ]
      interface WebTransportStream {
          readonly attribute unsigned long long streamId;
          readonly attribute WebTransport transport;
      };
      </pre>
      <section>
        <h2>Attributes</h2>
        <dl data-link-for="WebTransportStream" data-dfn-for="WebTransportStream" class=
        "attributes">
          <dt><dfn><code>streamId</code></dfn> of type <span class=
          "idlAttrType"><a>unsigned long long</a></span>, readonly</dt>
          <dd>
            <p>The readonly attribute referring to the ID of the
            <code><a>TransportStream</a></code> object.</p>
          </dd>
          <dt><dfn><code>transport</code></dfn> of type <span class=
          "idlAttrType"><a>WebTransport</a></span>, readonly</dt>
          <dd>
            <p>The readonly attribute referring to the related <code><a>WebTransport</a></code> object.</p>
          </dd>
        </dl>
      </section>
    </div>
  </section>

  <section id="bidirectional-stream*">
    <h2>Interface <dfn>BidirectionalStream</dfn></h2>
    <div>
      <pre class="idl">
      [ Exposed=Window ]
      interface BidirectionalStream : WebTransportStream {
      };
      BidirectionalStream includes OutgoingStream;
      BidirectionalStream includes IncomingStream;
      </pre>
    </div>
  </section>

  <section id="send-stream*">
    <h2>Interface <dfn>SendStream</dfn></h2>
    <div>
      <pre class="idl">
      [ Exposed=Window ]
      interface SendStream : WebTransportStream {
      };
      SendStream includes OutgoingStream;
      </pre>
    </div>
  </section>

  <section id="receive-stream*">
    <h3>Interface <dfn>ReceiveStream</dfn></h3>
    <div>
      <pre class="idl">
      [ Exposed=Window ]
      interface ReceiveStream : WebTransportStream {
      };
      ReceiveStream includes IncomingStream;
      </pre>
    </div>
  </section>

  <section id="http3-transport*">
    <h2><dfn>Http3Transport</dfn> Interface</h2>
    <section id="http3-transport-overview*">
      <h3>Overview</h3>
      <p>An <code><a>Http3Transport</a></code> is a
      <code>UnidirectionalStreamsTransport</code>, a
      <code>BidirectionalStreamsTransport</code>, and a
      <code>DatagramTransport</code>.
      SendStreams, ReceiveStreams, and BidirectionalStreams are implemented with
      HTTP/3 streams as defined in [[WEB-TRANSPORT-HTTP3]]. Datagrams are
      implemented with QUIC datagrams as defined in [[WEB-TRANSPORT-HTTP3]].
      </p>
    </section>
    <section id="http3-transport-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
[ Constructor (DOMString url), Exposed=Window]
interface Http3Transport {
};

Http3Transport includes UnidirectionalStreamsTransport;
Http3Transport includes BidirectionalStreamsTransport;
Http3Transport includes DatagramTransport;
Http3Transport includes WebTransport;</pre>
      </div>
        <section>
          <h2>Constructors</h2>
          When the <code><a>Http3Transport</a></code> constructor is invoked,
          the user agent <em class="rfc2119" title="MUST">MUST</em> run the
          following steps:
          <ol>
            <li>
              Let <var>transport</var> be a newly constructed
              <code><a>Http3Transport</a></code> object with state "connecting".
            </li>
            <li>Let <var>transport</var> have a <a>[[\OutgoingStreams]]</a>
              internal slot representing a sequence of <code><a>OutgoingStream</a></code>
              objects, initialized to empty.
            </li>
            <li>Let <var>transport</var> have a <a>[[\ReceivedStreams]]</a>
              internal slot representing a <code><a>ReadableStream</a></code>
              of <code><a>IncomingStream</a></code> objects, initialized to empty.
            </li>
            <li>Let <var>transport</var> have a <a>[[\ReceivedBidirectionalStreams]]</a>
              internal slot representing a <code><a>ReadableStream</a></code>
              of <code><a>IncomingStream</a></code> objects, initialized to empty.
            </li>
            <li>Let <var>transport</var> have a <dfn>[[\SentDatagrams]]</dfn>
              internal slot representing a <code>WritableStream</code> of <code>Uint8Array</code>s,
              initialized to empty.
            </li>
            <li>Let <var>transport</var> have a <dfn>[[\ReceivedDatagrams]]</dfn>
              internal slot representing a <code>ReadableStream</code> of <code>Uint8Array</code>s,
              initialized to empty.
            </li>
            <li>Run these steps in parallel:
              <ol>
                <li>
                  Either establish an HTTP/3 connection or reuse an existing HTTP/3
                  connection to the host specificed by the url, as specified in [[WEB-TRANSPORT-HTTP3]].
                </li>
                <li>
                  If there is no such HTTP/3 connection to reuse and the establishment of a 
                  new HTTP/3 connection, set <var>transport</var>'s <a>[[\WebTransportState]]</a>
                  internal slot to <code>"failed"</code> and abort these steps.
                </li>
                <li>
                  Once a connection an HTTP/3 connection is established, follow the
                  steps specified in [[WEB-TRANSPORT-HTTP3]] section 4 for
                  establishing a WebTransport session within the HTTP/3 connection.
                </li>
                <li>
                  If the establishment of the WebTransport session fails, 
                  set <var>transport</var>'s <a>[[\WebTransportState]]</a>
                  internal slot to <code>"failed"</code> and abort these steps.
                </li>
                <li>
                  Once a session has been established, set <var>transport</var>'s 
                  <a>[[\WebTransportState]]</a> internal slot to <code>"connected"</code>
                  and abort these steps.
                </li>
              </ol>
            </li>
            <li>
              Return <var>transport</var>.
            </li>
          </ol>          
          <dl data-link-for="Http3Transport" data-dfn-for="Http3Transport" class=
          "constructors">
            <dt><code><a>Http3Transport</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">url</td>
                    <td class="prmType"><code><a>DOMString</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc">The url specifying the host to connect to and the path to pass to it.</td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>

  <section id="privacy-security">
    <h2>Privacy and Security Considerations</h2>
    <p>This section is non-normative; it specifies no new behaviour, but
    instead summarizes information already present in other parts of the
    specification.</p>
    <!-- TODO: Add a section about the origin transport parameter -->
    <section>
      <h2>Confidentiality of Communications</h2>
      <p>The fact that communication is taking place cannot be hidden from
      adversaries that can observe the network, so this has to be regarded as
      public information.</p>
      <p>All of the transport protocols described in this document use either
      TLS [[TLS13]] or a semantically equivalent protocol, thus providing all
      of the security properties of TLS, including confidentiality and
      integrity of the traffic.  Both QuicTransport and Http3Transport use the
      same certificate verification mechanism as outbound HTTP requests, thus
      relying on the same public key infrastructure for authentication of the
      remote server.  In WebTransport, certificate verification errors are
      fatal; no interstitial allowing bypassing certificate validation is
      available.</p>
    </section>
    <section>
      <h2>State Persistence</h2>
      <p>WebTransport by itself does not create any new unique identifiers or
      new ways to persistently store state, nor does it automatically expose
      any of the existing persistent state to the server.  For instance, none
      of the transports defined in this document automatically send cookies,
      support HTTP authentication or caching invalidation mechanisms.  Since
      they use TLS, they may support TLS session tickets, which could be used
      by the server (though not by passive network observers) to correlate
      different connections from the same client.  This is not specific to
      WebTransport by itself, but rather an inherent property of all TLS-based
      protocols; thus, this is out-of-scope for this specification.</p>
    </section>
    <section>
      <h2>Protocol Security</h2>
      <p>WebTransport imposes a common set of requirements on all of the
      protocols, described in [[WEB-TRANSPORT-OVERVIEW]].  Notable ones
      include:</p>
      <ol>
        <li>All transports must ensure that the remote server is aware that the
          connection in question originates from a Web application; this is
          required to prevent cross-protocol attacks.  QUIC-based transports
          use [[ALPN]] for that purpose.</li>
        <li>All transports must allow the server to filter connections based on
          the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-settings-object-origin">origin</a>
          of the resource originating the transport session.</li>
        <li>All transports require the user agents to continually verify that
          the server is still interested in talking to them (concept commonly
          known as "Consent Freshness").</li>
      </ol>
      <p>Protocol security considersations related to the individual transports
      are described in the <i>Security Considerations</i> sections of the
      corresponding protocol documents, [[WEB-TRANSPORT-QUIC]] and
      [[WEB-TRANSPORT-HTTP3]].</p>
      <p>Networking APIs can be commonly used to scan the local network for
      available hosts, and thus be used for fingerprinting and other forms of
      attacks.  WebTransport follows the <a
                 href="https://html.spec.whatwg.org/multipage/web-sockets.html#feedback-from-the-protocol">
        WebSocket approach</a> to this problem: the specific connection error
      is not returned until an endpoint is verified to be a WebTransport
      endpoint; thus, the Web application cannot distinguish between a
      non-existing endpoint and the endpoint that is not willing to accept
      connections from the Web.</p>
    </section>
  </section>

  <section class="informative">
    <h2>Event summary</h2>
    <p>The following events fire on transport objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>ErrorEvent</a></code></td>
          <td>The <code><a>WebTransport</a></code> object has encountered an error.</td>
        </tr>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>WebTransportState</a></code> changed.</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section id="examples*">
    <h2>Examples</h2>
    <section class="informative" id="unreliableexamples*">
      <h3>Unreliable delivery</h3>
      <p>Unreliable delivery can be achieved by creating many streams with retransmissions disabled,
      each transporting a single small message.</p>
      <pre class="example highlight">
let transport = getTransport();
let messages = getMessages();
for (msg in messages) {
  transport.createSendStream({disableRetransmissions: true}).writable.getWriter().write({data: msg, finished: true});
}</pre>
    </section>

    <section class="informative" id="datagramexample1*">
      <h3>Sending a buffer of datagrams</h3>
      <p>Sending a buffer of datagrams can be achieved by using the
      <code>sendDatagrams</code> method. In
      the following example datagrams are only sent if the
      <code>DatagramTransport</code> is ready to send.</p>
      <pre class="example highlight">
const transport = getTransport();
const datagramWritableStream = transport.sendDatagrams();
const datagrams = getDatagramsToSend();
datagrams.forEach((datagram) => {
  await datagramWritableStream.getWriter().ready;
  datagramWritableStream.getWriter().write(datagram);
});</pre>
    </section>

    <section class="informative" id="datagramexample2*">
      <h3>Sending datagrams at a fixed rate</h3>
      <p>Sending datagrams at a fixed rate regardless if the transport is ready to
      send can be achieved by simply using <code>sendDatagram</code> and not using
      the <code>ready</code> attribute. More complex scenarios can utilize
      the <code>ready</code> attribute.</p>
      <pre class="example highlight">
// Sends datagrams every 100 ms.
const transport = getTransport();
const datagramWritableStream = transport.sendDatagrams();
setInterval(() => {
  datagramWritableStream.getWriter().write(createDatagram());
}, 100);</pre>
    </section>

    <section class="informative" id="datagramexample3*">
      <h3>Receiving datagrams</h3>
      <p>Receiving datagrams can be achieved by calling
      <code>receiveDatagrams()</code>  method, remembering to check for null values
      indicating that packets are not being processed quickly enough.
      </p>
      <pre class="example highlight">
      const transport = getTransport();
      const reader = transport.receiveDatagrams().getReader();
      while (true) {
        const {value: datagram, done} = await reader.read();
        if (done) {
          break;
        }
        // Process the data
      }
      </pre>
    </section>
  </section>

  <section id="change-log*">
    <h2>Change Log</h2>
    <p>This section will be removed before publication.</p>
  </section>

  <section class="appendix">
    <h2>Acknowledgements</h2>
    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan H&aring;kansson, Bernard Aboba and Dominique
    Haza&euml;l-Massieux, for their support. Contributions to this
    specification were provided by Robin Raymond.</p>
    <p>The <code><a>QuicTransport</a></code> and <code>QuicStream</code> objects
    were initially described in the <a href="https://www.w3.org/community/ortc/">W3C ORTC CG</a>,
    and have been adapted for use in this specification.</p>
  </section>
</body>
</html>
